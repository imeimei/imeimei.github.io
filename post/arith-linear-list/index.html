<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>线性表 - Keep It Simple</title>
    <meta name="keywords" content="爱呆,博客,程序员,思考,读书,笔记,技术,分享,Golang">
    
    <meta property="og:title" content="线性表">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="线性表 - Keep It Simple" />
    <meta name="description" content="爱呆 | 博客 | 软件 | C&#43;&#43; | Golang"> 
    
    <link rel="shortcut icon" href="https://halohui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://halohui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://halohui.github.io/img/apple-touch-icon.png" />
    <link href="https://halohui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://halohui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://halohui.github.io/css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://halohui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一指流沙，程序年华</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://halohui.github.io/post/arith-linear-list/" itemprop="url">
        线性表
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建于:</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-04-25">
    2018-04-25
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新于:</span>
<time itemprop="dateUpdated" content="2018-04-25">
    2018-04-25
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类:</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://halohui.github.io/categories/%E7%AE%97%E6%B3%95" itemprop="url" rel="index">
        <span itemprop="name">算法</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数统计:</span>
<span class="leancloud-visitors-count">5693</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读时长:</span>
<span class="leancloud-visitors-count">12</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
      

<h2 id="线性表">线性表</h2>

<h3 id="特征">特征</h3>

<p>线性表是由 $n$个元素$(n \ge 0)$组成的有限序列，线性表的特征在于：</p>

<ul>
<li><p>线性表中所有<font color=red>数据元素类型相同</font>。</p></li>

<li><p>线性表由<font color=Blue>有限个数据元素构成</font>。</p></li>

<li><p>线性表中<font color=red>数据元素是位置相关的</font>，这一点表明线性表<font color=Blue>不同于集合</font>，线性表中<font color=Blue>每个元素都有一个对应的序号</font>，线性表中的<font color=red>元素可以重复出现的。</font></p></li>
</ul>

<hr />

<h3 id="逻辑结构">逻辑结构</h3>

<p>线性表的逻辑结构一般表示为:<code>$(a_1,a_2,...,a_{i-1},a_i,a_{i+1},...,a_n)$</code></p>

<ul>
<li><p>除了<font color=red>起始元素$a_1$没有前驱元素</font>之外，其他元素$a_i$<font color=Blue>有且仅有一个</font>前驱元素<code>$a_{i-1}$</code>。</p></li>

<li><p>除了<font color=Blue>终端元素$a_n$没有后继元素</font>外，其他元素$a_i$<font color=Blue>有且仅有一个</font>后继元素<code>$a_{i+1}$</code>。</p></li>
</ul>

<p>线性表是一种<font color=Blue>逻辑结构</font>，线性表的存储结构有两种：</p>

<ul>
<li><p>顺序存储：顺序表</p></li>

<li><p>链式存储：单链表</p></li>
</ul>

<hr />

<h2 id="顺序表">顺序表</h2>

<p>线性表的顺序存储是指<font color=Blue>一组地址连续的存储单元依次存储线性表中的各个元素</font>，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素<font color=GoldenRod>物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系</font>，采用顺序存储结构的线性表通常称为顺序表。</p>

<h3 id="顺序表的特点">顺序表的特点</h3>

<ul>
<li><p>属于直接映射——<font color=Blue>逻辑上相邻的元素，其物理位置也相邻</font>。</p></li>

<li><p>具有随机存取特性，通过<font color=GoldenRod>首地址和元素序号</font>可以在 $O(1)$ 时间内找到指定元素。</p></li>

<li><p>存储密度高，其值为$1$。$存储密度=\frac{节点数据本身所占用的存储量}{节点结构占用的存储量}$</p></li>

<li><p>删除和插入元素需要移动大量元素：</p>

<ul>
<li><p>插入元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i+1)=\frac{n}{2}$, 因此时间复杂度为$O(n)$。</p></li>

<li><p>删除元素移动的平均次数$=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$，因此时间复杂度为$O(n)$。</p></li>
</ul></li>
</ul>

<hr />

<h3 id="描述顺序表的结构">描述顺序表的结构</h3>

<p>为了描述顺序表，需要知道：①顺序表的起始地址；②顺序表的最大长度；③顺序表的当前长度。</p>

<pre><code class="language-cpp">#define MaxSize 100
typedef struct
{
       int data[MaxSize];
       int length;
} SqList;
</code></pre>

<hr />

<h3 id="最长平台">最长平台</h3>

<p>给定一个有$n$ 个元素的整型数组$arr$,其中连续的<font color=GoldenRod>相等元素构成的子序列</font>称为平台，设计一个算法求 $arr$中最长平台的长度。</p>

<pre><code class="language-cpp">int maxLength(int arr[], int n)
{
    int len = 1;
    int max = 1;
    int start = 0; //可以记录下标，也可以直接记录

    for (int i = 1; i &lt; n; i++)
    {
        if (arr[i] == arr[start])
            len++;
        else
        {
            if (len &gt; max)
                max = len;

            start = i;
            len = 1;
        }
    }

    if (len &gt; max)  //有可能是最后的那一段是最长平台
        max = len;

    return max;
}
</code></pre>

<hr />

<h3 id="以0为轴调整">以0为轴调整</h3>

<p>设有一个顺序表$L$, 其元素为整型数据，设计一个算法将$L$中所有小于$0$的整数放在前半部分，大于等于$0$的整数放在后半部分。</p>

<pre><code class="language-cpp">void change(SqList &amp;L)
{
    int tmp;
    int i = 0, j = L.length - 1;
    while (i &lt; j)
    {
        while (i &lt; j &amp;&amp; L.data[i] &lt; 0)
            i++;
        while (i &lt; j &amp;&amp; L.data[j] &gt;= 0)
            j--;
        if (i &lt; j)
        {
            tmp = L.data[i];
            L.data[i] = L.data[j];
            L.data[j] = tmp;
        }
    }
}
</code></pre>

<hr />

<h3 id="以第一个元素为轴调整">以第一个元素为轴调整</h3>

<p>设有一个顺序表$L$，其元素为整型。设计一个尽可能高效的算法，<font color=GoldenRod>以第一个元素为分界线</font>，将所有小于等于它的元素移到该元素前面，将所有大于它的元素移到该元素的后面。</p>

<pre><code class="language-cpp">void move1(SqList &amp;L)
{
    int i = 0;
    j = L.length - 1;
    int pivot = L.data[0];
    int tmp;

    while (i &lt; j)
    {
        while (i &lt; j &amp;&amp; L.data[j] &gt; pivot)
            j--;
        while (i &lt; j &amp;&amp; L.data[i] &lt;= pivot)  //第一个元素肯定会被忽略掉
            i++;

        //此处可以添加一个 i &lt; j 的判断，这里省略掉是因为前面已经判断i&lt;j,
        //所以到这里的时候最多也是i==j, 这时候直接交换也是没有副作用的
        tmp = L.data[i];
        L.data[i] = L.data[j];
        L.data[j] = tmp;

    }

    if (L.data[i] &lt; pivot)//因为忽略了第一个元素，因此这里需要检查最终位置的那个元素和第一个元素的大小关系
    {
        tmp = L.data[0];
        L.data[0] = L.data[i];
        L.data[i] = tmp;
    }
}

void move2(SqList &amp;L)
{
    int i = 0, j = L.length - 1;
    int pivot = L.data[0];

    while (i &lt; j)
    {
        while (i &lt; j &amp;&amp; L.data[j] &gt; pivot)  j--;  //先从最后开始，因为第一个元素需要首先被替换
        if(i &lt; j )
        { 
           L.data[i] = L.data[j];  
           i++;
        }  
        
        while (i &lt; j &amp;&amp; L.data[i] &lt;= pivot) i++；
        if(i&lt;j)
        {
          L.data[j] = L.data[i];
          j--;
        }
    }
    L.data[i] = pivot;  //最后找到最终的位置
}


void move3(SqList &amp;L) //剑指offer里快速排序的思路
{                     //该算法可以保持相对次序不变
    int i = 0;
    int pivot = L.data[0];
    int tmp;

    for (int j = 1; j &lt; L.length; j++)
    {
        if(data[j] &lt; pivot)
        {
           i++;
           if (i &lt; j)  //是小于不是&lt;=,因为第一个元素要被替换掉
           {
             tmp = L.data[i];
             L.data[i] = L.data[j];
             L.data[j] = tmp;
          }
        }   
    }
    tmp = L.data[0];  //最后交换下标为0的元素和下标为i的元素
    L.data[0] = L.data[i];
    L.data[i] = tmp;
}
</code></pre>

<hr />

<h3 id="删除元素">删除元素</h3>

<p>已知长度为$n$的线性表$L$采用顺序存储结构，编写一个时间复杂度为$O(n)$,空间复杂度为$O(1)$ 的算法，该算法删除线性表中所有值为$x$的数据元素。</p>

<pre><code class="language-cpp">void deleteSameElements1(SqList &amp;L, int x)
{
    int base = 0;

    for (int i = 0; i &lt; L.length; i++)
    {
        if (L.data[i] != x)
        {
            L.data[base] = L.data[i];
            base++;
        }
    }
    L.length = base;
}

void deleteSameElements2(SqList &amp;L, int x)
{
    int count = 0;
    int i = 0;

    while (i &lt; L.length)
    {
        if (L.data[i] == x)
            count++;
        else
            L.data[i - count] = L.data[i];//不同的是记录目前等于x的元素个数
        i++;
    }
    L.length = L.length - count;
}
</code></pre>

<p>一般<font color=Blue>类似的题目</font>有：已知长度为$n$的线性表$L$ 采用顺序存储结构，试设计一个时间复杂度空间复杂度两方面都尽可能高效的算法，该算法删除线性表中元素值为$[x,y]$之间的所有数据元素。</p>

<hr />

<h2 id="单链表">单链表</h2>

<p>单链表是<font color=Blue>任意一组存储单元存放线性表中的元素</font>，每个节点通过一个指针指向其后继节点。这组<font color=red>存储单元可以是连续的也可以是不连续的。</font>单链表具有如下的特点：</p>

<ul>
<li><p>通过首节点(带<font color=Blue>哨兵节点</font>或不带哨兵节点)的指针来标识一个单链表。</p></li>

<li><p>从一个已知节点出发，<font color=Green>只能访问该节点和通过 $next$ 指针访问其后继节点</font>，<font color=red>无法直接找到</font>该节点之前的其他节点</p></li>

<li><p>在单链表中插入一个节点或者删除一个节点必须找到其前驱节点，<font color=Blue>插入和删除操作不需要移动节点</font>。「<font color=red>删除一个节点也可以不用知道其前驱节点</font>，只要将其后继节点的元素内容往前移到当前节点，并将当前节点的后继修改为其后继节点的后继节点，然后删除后继节点即可。<font color=Blue>但是要考虑该节点是否为最后一个节点，或者第一个节点」</font></p></li>
</ul>

<pre><code class="language-cpp">typedef struct LinkedNode
{
  T data;  //T表示数据类型
  struct LinkedNode* next;
}LinkedList;
</code></pre>

<hr />

<h3 id="建立单链表">建立单链表</h3>

<p>建立单链表有两种方式，一种是从头部插入；另一种是从尾部插入。从头部插入节点生成的单链表，最后<font color=red>节点元素顺序与插入元素的顺序相反，即成逆序排列了。</font></p>

<pre><code class="language-cpp">   void creatLinkedList（LinkedList* &amp;L, int * a,int n)
   {
     LinkedList* cur;
     L=(LinkedList*)malloc(sizeof(LinkedList));
     L-&gt;next=NULL;
     
     for(int i=0;i&lt;n;i++)
     {
       cur=(LinkedList*)malloc(sizeof(LinkedList));
       cur-&gt;data=a[i];
       cur-&gt;next=L-&gt;next;
       L-&gt;next=cur;  //当前节点成为哨兵节点的下一个节点
     }
   }
</code></pre>

<hr />

<p>尾插法是在单链表的尾部插入节点元素，最后<font color=Blue>生成的单链表的节点元素顺序和插入元素的顺序是相同的</font>。</p>

<pre><code class="language-cpp">  void creatLinkedList（LinkedList* &amp;L, int*a,int n)
   {
     LinkedList* cur，*tail;
     L=(LinkedList*)malloc(sizeof(LinkedList));
     tail=L; //tail始终指向最后的节点，开始时指向链表的头结点
     
     for(int i=0;i&lt;n;i++)
     {
       cur=(LinkedList*)malloc(sizeof(LinkedList));
       cur-&gt;data=a[i];
       tail-&gt;next=cur;
       tail=cur;
     }
     tail-&gt;next=NULL;
   }
</code></pre>

<hr />

<h3 id="基本操作">基本操作</h3>

<ol>
<li>按序号查找节点值算法</li>
</ol>

<pre><code class="language-cpp">  bool findNode(LinkedList *L,int i,int &amp;result)
  {
    int j=0;
    LinkedList *cur=L;
    
    while(cur!=NULL &amp;&amp; j&lt;i)
    {
      j++;
      cur=cur-&gt;next;
    }
    if(NULL==cur) return false;
         
    result=cur-&gt;data;
    return true;
    
  }
</code></pre>

<hr />

<ol>
<li>按元素值查找序号算法</li>
</ol>

<pre><code class="language-cpp">  int findNode(LinkedList *L,int key)
  {
    LinkedList *cur=L-&gt;next;
    int index=0;
    
    while(cur!=NULL &amp;&amp; cur-&gt;data!=key)
    {
      index++;
      cur=cur-&gt;next;
    }
    
    if(cur!=NULL) return index;
    else return -1;  //返回-1，表示没有找到该元素
  }
</code></pre>

<hr />

<ol>
<li>插入元素：将值为$x$的元素的新节点插入到第$i$个节点的位置上，即先在单链表中找到插入节点的前驱节点，即第$i-1$个节点，再在其后插入新节点。
<br /></li>
</ol>

<pre><code class="language-cpp">    cur-&gt;next=pre-&gt;next;  //cur表示将要插入到链表中的节点,插入的位置是节点pre之后
    pre-&gt;next=cur;
</code></pre>

<ol>
<li>删除元素:将单链表中的第$i$个节点删除。</li>
</ol>

<pre><code class="language-cpp">    cur=pre-&gt;next;     //pre-&gt;next是待删除的节点，cur是待删除节点的上一个节点
    pre-&gt;next=cur-&gt;next;
    free (cur);
</code></pre>

<hr />

<h3 id="就地逆置">就地逆置</h3>

<p>有一个线性表$(a_1,a_2,&hellip;,a_n)$ 采用带哨兵节点的单链表$L$存储，设计一个就地算法将其就地逆置，<font color=Blue>所谓“就地”是指算法的辅助空间为$O(1)$。</font></p>

<pre><code class="language-cpp">void reverse(LinkedList * &amp; L) //传入引用
{
  LinkedList *cur=L-&gt;next;
  LinkedList *next;
  L-&gt;next=NULL;
  while(cur!=NULL)
  {
    next=ptr-&gt;next;    //先保存下一个节点，然后使用头插法进行逆置
    cur-&gt;next=L-&gt;next; 
    L-&gt;next=cur;
    cur=next;
  }
}

</code></pre>

<hr />

<h3 id="拆分链表">拆分链表</h3>

<p>设$C={a_1,b_1,a_2,b_2,&hellip;,a_n,b_n}$ 为一线性表，采用带哨兵节点的$hc$单链表存放，设计一个就地算法，将其拆分为两个线性表（它们都是用单链表存放）使得$A={a_1,a_2,&hellip;,a_n},B={b<em>n,b</em>{n-1},&hellip;,b_2,b_1}$，即$A$是正序排列，$B$是逆序排列。</p>

<pre><code class="language-cpp">//参数传入引用，ha存储是A，hb存储的是B
void split(LinkedList *hc,LinkedList *&amp;ha,LinkedList *&amp; hb)
{
  LinkedList *tail=ha;
  LinkedList *cur=hc-&gt;next;
  LinkedList *next;
  
  hb-&gt;next=NULL;
  while(cur != NULL)
  {
    tail-&gt;next=cur;      //尾插法
    tail=cur;
    
    cur=cur-&gt;next;
    
    next=cur-&gt;next;
    cur-&gt;next= hb-&gt;next;  //头插法
    hb-&gt;next= cur;
    cur=next;
  }
  tail-&gt;next=NULL;  //别忘了
}
</code></pre>

<hr />

<h3 id="递增排序">递增排序</h3>

<p>有一个带哨兵结点的单链表$L$,设计一个算法使其元素<font color=Blue>递增有序</font>。最基本的想法是使用<font color=red>直接插入排序</font>的思想，一个一个排，不同于数组排序，这里<font color=Blue>单链表只能从头开始查找。</font></p>

<pre><code class="language-cpp">void sort（LinkedList * &amp;L)
{
  LinkedList *cur=L-&gt;next;
  LinkedList *next=cur-&gt;next;
  LinkedList *pre,*assist; //
  
  cur-&gt;next=NULL;   //只含有一个元素的有序单链表
  cur=next;
  
  while(cur!=NULL)
  {
    next=cur-&gt;next;   //首先保存下一个链表节点
    pre=L;            //单链表只能从头开始往后寻找节点
    
    assist=pre-&gt;next; //assist从头开始遍历
    while(assist!=NULL &amp;&amp; assist-&gt;data &lt; cur-&gt;data)
    {
      pre=assist;   //pre记录插入位置的前一个节点
      assist=assist-&gt;next;
    }
    
    cur-&gt;next=pre-&gt;next; //pre的下一个节点就是要插入的位置
    pre-&gt;next=cur;       //pre的下一个节点就是要插入的位置
    
    cur=next;   
  }
}
</code></pre>

<hr />

<h3 id="公共节点">公共节点</h3>

<p>给定两个单链表，编写算法找出其公共的节点。第一种方法分析：从头到尾扫描单链表$A$，判断当前元素是否在单链表$B$中出现，若在则插入到单链表$C$中。</p>

<pre><code class="language-cpp">void findSameNode(LinkedList *A,LinkedList *B,LinkedList *&amp;C)
{
  LinkedList *curA=A-&gt;next;
  LinkedList *curB=B-&gt;next;
  LinkedList *tail;       //尾插法构建新的单链表
  
  C=(LinkedList*)malloc(sizeof(LinkedList));  //静态存储区分配内存
  C-&gt;next=NULL;
  tail=C;
  while(curA!=NULL)
  {
    curB=B-&gt;next;
    while(curB!=NULL &amp;&amp; curB-&gt;data!= curA-&gt;data)
              curB=curB-&gt;next;
    
    if(curB!=NULL)
    {
      tail-&gt;next=curA;
      tail=curA;
    }
    curA=curA-&gt;next;
  }
  tail-&gt;next=NULL;  //尾插法最后应该将尾巴的next域置空
}
</code></pre>

<p>第二种方法分析：借用<font color=Blue>两个辅助栈，分别存储两个链表遍历时的序列，然后同时将两个辅助栈中元素弹出，直到弹出的元素不相等，</font>弹出时采用头插法进行构造新的单链表。</p>

<p>第三种方法分析：首先遍历两个链表，得到两个单链表的长度差$k$，然后长的单链表<font color=red>先走$k-1$步，</font>然后短的和长的同时走，直到遇到相等的元素，即为新的单链表的首节点。</p>

<hr />

<h2 id="精选习题">精选习题</h2>

<h3 id="循环左移">循环左移</h3>

<p>将$n$个整数存放到一维数组$R$中。试设计一个在时间和空间尽可能高的算法。将$R$中保存的序列循环左移$p （0 \lt q\lt n)$个位置，即将$R$中的数据由<code>$(X_0,X_1,...,X_{n-1})$</code>变换为<code>$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,....,X_{p-1})$</code></p>

<pre><code class="language-cpp">void reverse(int R[],int start,int end)
{
 int i=start,j=end;
 int assist;
 while(i&lt;j)
 {
   assist=R[i];
   R[i]=R[j];
   R[j]=assist;
   i++;
   j--;
 }
}

void leftShift(int R[],int n,int p)
{
  if(p&gt;0 &amp;&amp;p&lt;n)
  {
   reverse(R,0,n-1);
   reverse(R,0,n-p-1);
   reverse(R,n-p,n-1);
  }
}
</code></pre>

<hr />

<h3 id="寻找中位数">寻找中位数</h3>

<p>给定两个数组$A$和$B$,数组的长度为$n$,两个数组都分别有序，求出<font color=Blue>两个数组中的所有数排序后的中位数</font>「偶数序列中间两数的前一个为其中位数」。</p>

<h4 id="解法一">解法一</h4>

<p>因为数组$A$和$B$均有序，因此将两个数组排序后，<font color=red>第$n$个数</font>就是题目中所要找的中位数。</p>

<pre><code class="language-cpp">int search(int A[],int B[],int n)
{
  int i=0,j=0,k=0;
 
  while(i &lt; n &amp;&amp; j &lt; n)
  {
    k++;
    if(A[i]&lt;B[j])
    {
      if(k == n)
        return A[i];
       i++;
    }
    else
    {
      if(k == n)
        return B[j];
      j++;
    }
  }
}
</code></pre>

<hr />

<h4 id="解法二">解法二</h4>

<p>分别求出两个升序序列$A$，$B$的中位数，记为$a，b$。若$a=b$,则$a$或$b$即为所求，否则舍弃$a,b$中较小者所在序列的较小一半，同时舍弃较大者所在序列的较大一半，<font color=red>要求两次舍弃的元素个数相同（每次从左侧和右侧删除相同个数的元素后，新的两个数组，它们的中位数与原始数组的中位数是相同的）。</font>重复上述过程，直到<font color=Blue>两个序列均只含一个元素为止</font>，则较小的即为所求的中位数。</p>

<pre><code class="language-cpp">int searchMid(int A[],int B[],int n)
{
  int startA,midA,endA;
  int startA,midB,endB;
  
  startA=0; endA=n-1; 
  startB=0; endB=n-1;
  
  while(startA!=endA || startB!=endB)
  {
     midA=(startA+endA)/2;
     midB=(startB+endB)/2;
     
     if(A[midA]==B[midB])
        return A[midA];
        
     if(A[midA]&lt;B[midB])
     {
       if((startA+endA)%2==0)//若元素个数为奇数时
       {
         startA=midA;  //舍弃A中间点以前的部分且保留中间点
         endB=midB;    //舍弃B中间点以后的部分且保留中间点
       }
       else  //若元素个数为偶数时
       {
        startA=midA+1;  //舍弃A的前半部分,每次舍弃的长度相同，可以保证同时到达
        endB=midB;      //舍弃B的后半部分
       }
     }
     else if(A[midA] &gt; B[midB])
     {
       if((startA+endA)%2==0)//若元素个数为奇数时
       {
         endA=midA;  //舍弃A中间点以后的部分且保留中间点
         startB=midB;//舍弃B中间点以前的部分且保留中间点
       }
       else  //若元素个数为偶数时
       {
        endA=midA;       //舍弃A的后半部分
        startB=midB+1;   //舍弃B的前半部分
       }
     }
  }
  
  return A[startA]&lt;B[startB]?A[startA]:B[startB]; //较小者即为所求
}
</code></pre>

<ul>
<li><p>若$A$和$B$数组的长度为$2k+1$，取$A$数组的中位数为$A[k]$，$B$数组的中位数为$B[k]$，$A$和$B$组合起来的中位数应该是第$2k+1$大的那个数。如果$A[k]==B[k]$，则$A[k]$必定为第$2k+1$大的数，是所有数字的中位数。如果$A[k]\gt B[k]$，则$A[k]$至少为第$2k+2$大的数，$B[k]$至多为第$2k+1$大的数，中位数介于$B[k]$和$A[k]$之间。</p></li>

<li><p>若$A$和$B$数组的长度为$2k$，按照题目所述条件，则$A$的中位数为$A[k-1]$,则$B$的中位数为$B[k-1]$,$A$和$B$组合起来的中位数应该是第$2k$大的那个数，若$A[k-1]==B[k-1]$,则$B[k-1]$必为第$2k$大的那个数，即所有数字的中位数。如果$A[k-1]\gt B[k-1]$，则$A[k-1]$至少为第$2k$大的数，<font color=red>$B[k-1]$至多为第$2k-1$大的数，中位数介于$B[k-1]$和$A[k-1]$之间。</font></p></li>
</ul>

<hr />

<h3 id="次数大于一半">次数大于一半</h3>

<p>已知一个整数序列<code>$A=(a_0,a_1,...,a_{n-1})$</code>，在这个序列中若存在<font color=Blue>「不要求连续的序列」</font><code>$a_{p_1} = ... = a_{p_m} = x，0&lt;= a_{i} &lt; n, m &gt; n/2 , (0 &lt;= p_k &lt; n, 1&lt;=k&lt;=m)$</code>,则称 $x 为 A$ 的主元素，例如$A=(0,5,5,3,5,7,5,5)$,则$5$为主元素；又如$A=(0,5,5,3,5,1,5,7)$，则$A$中没有<font color=Blue>主元素</font>。假设$A$中的 $n$ 个元素保存在一个一维数组中，请设一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素，否则输出$-1$。</p>

<h4 id="解法一-1">解法一</h4>

<p>主元素问题方法一：对数组中元素进行计数，然后查看出现次数最多的元素，若次数大于一半，则为主元素。这种方式只需要对数组扫描一遍，时间复杂度为$O(n)$,空间复杂度为$O(n)$。</p>

<pre><code class="language-cpp">int moreThanHalf(int A[],int n)
{
  int *count=(int*)malloc(sizeof(int)*n);
  int index=0;
  
  for(int i=0;i&lt;n;i++) count[i]=0;
  
  for(int i=0;i&lt;n;i++)
  {
    count[A[i]]++;
    if(count[A[i]) &gt; count[A[index]]) index=A[i];
  }
  
  if(count[index]&gt;(n/2))  
     return index;
  else 
     return -1;
}
</code></pre>

<hr />

<h4 id="解法二-1">解法二</h4>

<p>首先使用快速排序，将元素排好序，然后统计相同元素出现的最大次数。统计的时候可以使用求最长平台的算法。时间复杂度为$O(nlogn)$,空间复杂度为$O(n)$。</p>

<pre><code class="language-cpp">void quickSort(int A[],int start,int end)
{
 int i=start,j=end;
  
 if(i&lt;j)
 {
    while(i&lt;j)
    {
      while(i&lt;j &amp;&amp; A[j]&gt;tmp) j--;
      A[i]=A[j];
      if(i&lt;j)
      {
        A[i]=A[j];
        i++;
       } 
      while(i&lt;j &amp;&amp; A[i]&lt;=tmp) i++;
      if(i&lt;j)
      {
        A[j]=A[i];
        j--;
       } 
    }
    quickSort(A,start,i-1);
    quickSort(A, i+1, end);
 }
}
//然后使用平台算法
</code></pre>

<hr />

<h4 id="解法三">解法三</h4>

<p>数组中存在主元素时，所有的非主元素个数和必少于一半。如<font color=red>让主元素与一个非主元素&rdquo;配对“，则最后多出来的元素（没有元素与之配对）就是主元素。</font>从前往后扫描数组元素，假定遇到的当前值选定为主元素，再次遇到它时计数加1，遇到不等的值时，计数减1。当计数减为0后，将遇到的下一个值重新选定为主元素。扫描完毕，当前选定的元素（计数值大于0）可能是主元素，但未必是主元素。还需要对数组再进行一次扫描，记录它出现的实际个数，以判定它是否是主元素。时间复杂度为$O(n)$,空间复杂度为 $O(1)$。</p>

<pre><code class="language-cpp">void moreThanHalf(int A[],int n)
{
 int pivot=A[0];
 int count=1;
 int count2=0;
 for(int i=1;i&lt;n;i++)
 {
   if(A[i]==base)
      count++;
   else 
   {  
       if(count&gt;0) count--;
       else 
       {
        pivot=A[i];
        count=1;
       }
    }
 }
 
 if(count &gt; 0)   
 {
    count2=0;  
    for(int i=0;i&lt;n;i++)
    {
      if(pivot==A[i])
        count2++;
    }
    
    if(count2 &gt; n/2)
        return pivot;
 }
    return ERROR; //ERROR 代表不会在序列中出现的那个数
}
</code></pre>

<hr />

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="https://halohui.github.io/tags/%e7%ae%97%e6%b3%95" rel="tag" title="算法">#算法#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://halohui.github.io/about/" rel="next" title="关于我">
        <i class="fa fa-chevron-left"></i> 关于我
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://halohui.github.io/post/travel-yunnan/" rel="prev" title="彩云之南">
        彩云之南 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     <div class="post-nav">
<div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
    <div style="float:left;margin-top:0px;">
    <img src="https://i.loli.net/2018/12/16/5c15cbd7f2b61.jpg" width="128px" height="128px"/>
    <div style="text-align:center;">谢谢支持!</div>
    </div>
    <div>
        <p style="margin-top:10px;">
            标题：线性表
        <br />作者：<a target="_blank" href="https://halohui.github.io/">I呆呆</a>
        
        <br />地址：https://halohui.github.io/post/arith-linear-list/
        <br />声明：自由转载-非商用-保持署名（创作共享3.0许可证）
        </p>
    </div>
</div>
<div class="clear"></div>
</div>
     
     
     




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://halohui.github.io/img/mmhui.png"
        alt="I呆呆" />
    <p class="site-author-name" itemprop="name">I呆呆</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://halohui.github.io/post/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://halohui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://halohui.github.io/tags/">
         
        <span class="site-state-item-count">16</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="酷 壳">
            <i class="fa fa-fw fa-globe"></i>
            酷 壳
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮一峰">
            <i class="fa fa-fw fa-globe"></i>
            阮一峰
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://github.com/qicosmos/" target="_blank" title="祁 宇">
            <i class="fa fa-fw fa-github"></i>
            祁 宇
        </a>
        </span>
    
</div>

      
      <div class="links-of-blogroll motion-element inline">


</div>
    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#线性表">线性表</a>
<ul>
<li><a href="#特征">特征</a></li>
<li><a href="#逻辑结构">逻辑结构</a></li>
</ul></li>
<li><a href="#顺序表">顺序表</a>
<ul>
<li><a href="#顺序表的特点">顺序表的特点</a></li>
<li><a href="#描述顺序表的结构">描述顺序表的结构</a></li>
<li><a href="#最长平台">最长平台</a></li>
<li><a href="#以0为轴调整">以0为轴调整</a></li>
<li><a href="#以第一个元素为轴调整">以第一个元素为轴调整</a></li>
<li><a href="#删除元素">删除元素</a></li>
</ul></li>
<li><a href="#单链表">单链表</a>
<ul>
<li><a href="#建立单链表">建立单链表</a></li>
<li><a href="#基本操作">基本操作</a></li>
<li><a href="#就地逆置">就地逆置</a></li>
<li><a href="#拆分链表">拆分链表</a></li>
<li><a href="#递增排序">递增排序</a></li>
<li><a href="#公共节点">公共节点</a></li>
</ul></li>
<li><a href="#精选习题">精选习题</a>
<ul>
<li><a href="#循环左移">循环左移</a></li>
<li><a href="#寻找中位数">寻找中位数</a>
<ul>
<li><a href="#解法一">解法一</a></li>
<li><a href="#解法二">解法二</a></li>
</ul></li>
<li><a href="#次数大于一半">次数大于一半</a>
<ul>
<li><a href="#解法一-1">解法一</a></li>
<li><a href="#解法二-1">解法二</a></li>
<li><a href="#解法三">解法三</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2018 - 2019</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>

  

<div class="theme-info">
  
  
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b07433b4ab8d587dae7d34e71973839";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=58416275" charset="UTF-8"></script> 
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://halohui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://halohui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://halohui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://halohui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/search.js"></script>
</body>
</html>
