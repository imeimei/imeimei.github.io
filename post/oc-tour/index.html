<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>OC 入门 - Keep It Simple</title>
    <meta name="keywords" content="爱呆,博客,程序员,思考,读书,笔记,技术,分享,Golang">
    
    <meta property="og:title" content="OC 入门">
    <meta property="og:site_name" content="Keep It Simple">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="OC 入门 - Keep It Simple" />
    <meta name="description" content="爱呆 | 博客 | 软件 | C&#43;&#43; | Golang"> 
    
    <link rel="shortcut icon" href="https://halohui.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="https://halohui.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="https://halohui.github.io/img/apple-touch-icon.png" />
    <link href="https://halohui.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="https://halohui.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="https://halohui.github.io/css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>

<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai-sublime.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="https://halohui.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Keep It Simple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一指流沙，程序年华</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/tags/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />标签
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/categories/%E6%97%85%E8%A1%8C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />旅行
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/categories/%E7%BE%8E%E9%A3%9F/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />美食
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="https://halohui.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		<!-- src = "http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> <\!--  -\-> -->
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="https://halohui.github.io/post/oc-tour/" itemprop="url">
        OC 入门
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">创建于:</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2018-09-19">
    2018-09-19
</time>
</span>
&nbsp; | &nbsp;
<span class="post-updated-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-check-o"></i>
</span>
<span class="post-meta-item-text">更新于:</span>
<time itemprop="dateUpdated" content="2018-09-19">
    2018-09-19
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类:</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="https://halohui.github.io/categories/oc" itemprop="url" rel="index">
        <span itemprop="name">OC</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-file-word-o"></i>
</span>
<span class="post-meta-item-text">字数统计:</span>
<span class="leancloud-visitors-count">6018</span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-coffee"></i>
</span>
<span class="post-meta-item-text">阅读时长:</span>
<span class="leancloud-visitors-count">13</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
      

<blockquote>
<p><code>Objective-C</code> 是<code>C</code>语言的严格超集——任何<code>C</code>语言程序<font color=red>不经过修改都可以直接通过<code>OC</code>的编译器</font>,在<code>OC</code>中使用<code>C</code>语言代码也是完全合法的。<code>Objective-C</code>被描述为<font color=Blue>覆盖在<code>C</code>语言上的薄薄一层</font>，因为<code>Objective-C</code>的原意就是在<code>C</code>语言的主体上加入面向对象的特性。</p>
</blockquote>

<h1 id="文件扩展名">文件扩展名</h1>

<table>
<thead>
<tr>
<th>文件扩展名</th>
<th>类型和作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>.h</td>
<td>头文件，包含类，类型，函数和常数声明</td>
</tr>

<tr>
<td>.m</td>
<td>源代码文件，典型的源代码文件扩展名，可以包含OC和C代码</td>
</tr>

<tr>
<td>.mm</td>
<td>源代码文件，带这种扩展名的源代码文件，除了可以包含OC和C代码以外，还可以包含C++代码</td>
</tr>
</tbody>
</table>

<p>源代码中需要包含头文件的时候，可以使用标准的<code>#include</code>编译选项，也可以使用<code>#import</code>选项，但是<code>OC</code>中使用<code>#import</code>可以<font color=red>确保相同的文件只包含一次</font>，因此一般使用<code>#import</code>来引入头文件。</p>

<hr />

<h1 id="语法">语法</h1>

<p><code>Objective-C</code>最大的特色使用<code>Smalltalk</code>的消息传递模型，在<code>OC</code>中与其说对象调用方法，<font color=red>不如说对象传递消息更为精确</font>。</p>

<h2 id="调用方法">调用方法</h2>

<p>在<code>OC</code>中，<font color=red>调用方法视为向对象发送消息，所有方法(类方法和实例方法)都被视为对消息的回应</font>。</p>

<p><font color=Blue>所有消息的处理直到运行时（<code>runtime</code>）才会动态决定</font>，并交<font color=red>由类自行决定如何处理收到的消息</font>。也就是说，<font color=red>一个类不保证一定会回应收到的消息</font>，如果类收到了一个无法处理的消息，程序<font color=Blue>只会抛出异常，不会出错或崩溃</font>。</p>

<p>在<code>OC</code>中发送消息的语法为：</p>

<pre><code class="language-objc">[obj method: argument];  //C++对应的是obj.method(argument);
</code></pre>

<p>一个例子:</p>

<pre><code class="language-objc">[car fly]
</code></pre>

<p>上面的例子典型的<code>C++</code>意义解读是:调用<code>car</code>类的<code>fly</code>方法。若<code>car</code>类里头没有定义<code>fly</code>方法，那编译肯定不会通过。但是<code>OC</code>里，应当解读为:发送一个<code>fly</code>的消息给<code>car</code>对象，<code>fly</code>是消息，而<code>car</code>是消息的接收者。<code>car</code>收到消息后会决定如何回应这个消息，若<code>car</code>类别内定义有<code>fly</code>方法就运行方法内之代码，若<code>car</code>内不存在<code>fly</code>方法，则程序依旧可以通过编译，运行期则抛出异常。</p>

<p>因此<code>OC</code>天生具备<font color=red>鸭子类型的动态类型绑定能力</font>，运行期间才处理消息，允许发送未知消息给对象，<font color=red>可以发送消息给整个对象集合而不需要检查每个对象的类型</font>，也具备消息转发机制。同时<font color=Blue>空对象<code>nil</code>接受消息后默认不做任何回应</font>，所以发送消息给<code>nil</code>也不用担心崩溃。</p>

<hr />

<h2 id="字符串">字符串</h2>

<p>作为<code>C</code>语言的超集，<code>OC</code>支持<code>C</code>语言字符串方面的约定：单个字符被单引号包括，字符串被双引号包括。但是，大多数<code>OC</code>通常不使用<code>C</code>语言风格的字符串，大多数框架把字符串传递给<code>NSString</code>对象<code>NSString</code>类提供了字符串的类包装，包含了所有你期望的优点——包括对保存任意长度字符串的内建内存管理机制，支持<code>Unicode</code>，<code>printf</code>风格的格式化工具等。</p>

<p>因为这种字符串使用的非常频繁，<font color=red><code>OC</code>提供了一个助记符可以方便地从常量值创建<code>NSString</code>对象</font>，即在普通的双引号字符串前放置一个<code>@</code>符号:</p>

<pre><code class="language-objc">NSString* myString = @&quot;My String\n&quot;;
NSString* anotherString = [NSString stringWithFormat:@&quot;%d %s&quot;, 1, @&quot;String&quot;];

// 从一个C语言字符串创建Objective-C字符串
NSString*  fromCString = [NSString stringWithCString:&quot;A C string&quot; 
encoding:NSASCIIStringEncoding];
</code></pre>

<hr />

<h2 id="类">类</h2>

<p><code>OC</code>类的说明包含两个部分：定义(<code>interface</code>)和实现(<code>implementation</code>)。定义包含了类声明和<font color=red>实例变量</font>的定义以及相关的方法；实现则包含了类方法的实际代码。</p>

<p><img src="http://oqe76o492.bkt.clouddn.com/15373419766634.jpg" alt="c600" /></p>

<p>类的声明<font color=red>总是以<code>@interface</code>编译选项开始，由<code>@end</code>编译选项结束。</font>类名之后的（用冒号分隔）是父类的名字。类的变量声明在被大括号包含的代码块中。变量块后是类声明的方法的列表，每个变量和方法声明都以分号结尾。</p>

<hr />

<h3 id="interface">Interface</h3>

<p>定义部分，以关键字<code>@interface</code>作为开始，<code>@end</code>作为结束，其中定义的<font color=red>实例变量的默认权限是<code>protected</code></font>的：</p>

<pre><code class="language-objc">@interface MyObject : NSObject {
    int memberVar1; // 实例变量，在定义部分声明的实例变量的默认访问权限是protected
    id  memberVar2; //id 类型表示任意类型
}

+(return_type) class_method; // 类方法

-(return_type) instance_method1; // 实例方法
-(return_type) instance_method2: (int) p1;
-(return_type) instance_method3: (int) p1 andPar: (int) p2;
@end
</code></pre>

<p>方法前面的<code>+</code>或者<code>-</code>号代表函数的类型：<font color=red>加号<code>+</code>代表类方法（<code>class method</code>）</font>，不需要实例就可以调用，与<code>C++</code>的静态函数（<code>static member function</code>）相似；<font color=Blue>减号<code>-</code>即是一般的实例方法（<code>instance method</code>）。</font></p>

<p>下面是与<code>OC</code>对应的相似的<code>C++</code>的声明：</p>

<pre><code class="language-cpp">class MyObject : public NSObject {
protected:
    int memberVar1;  // 实体变量
    void * memberVar2;

  public:
    static return_type class_method(); // 类方法

    return_type instance_method1();    // 实例方法
    return_type instance_method2( int p1 );
    return_type instance_method3( int p1, int p2 );
}
</code></pre>

<p><code>OC</code>定义一个新方法时，<font color=Blue>名称内的冒号代表传递参数</font>：</p>

<pre><code class="language-objc">- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 声明方法*/

[myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 调用方法*/
</code></pre>

<p>上面这个方法的<font color=red>签名是<code>setColorToRed:Green:Blue</code></font>。每个冒号后面都带着一个<code>float</code>类别的参数，分别代表红绿蓝三色。</p>

<hr />

<h3 id="implementation">Implementation</h3>

<p>实现块包含了公开的方法的实现，以及<font color=red>定义私有变量</font>以及方法，以关键字<code>@implementation</code>作为区块的开始，<code>@end</code>结尾。</p>

<pre><code class="language-objc">@implementation MyObject {
  int memberVar3; //私有实例变量
}

+(return_type) class_method {
    .... //方法的实现部分
}
-(return_type) instance_method1 {
     ....
}
-(return_type) instance_method2: (int) p1 {
    ....
}
-(return_type) instance_method3: (int) p1 andPar: (int) p2 {
    ....
}
@end
</code></pre>

<p>不只<code>Interface</code>区域可定义实体变量，<code>Implementation</code>区块也可以定义实体变量，两者的差别在于访问权限的不同，<font color=Blue><code>Interface</code>区块内的实体变量默认权限为<code>protected</code>。而在<code>implementation</code>区域定义的实体变量则默认为<code>private</code>，</font>故在<code>Implementation</code>区块定义<font color=red>私有成员更匹配面向对象之封装原则</font>，因为类的私有信息就不需暴露在公开<code>interface</code>(<code>.h</code>文件)中。</p>

<hr />

<h3 id="创建对象">创建对象</h3>

<p><code>OC</code>创建对象需通过<code>alloc</code>以及<code>init</code>两个消息,<code>alloc</code>的作用是分配内存，<code>init</code>是初始化对象。<font color=red><code>init</code>与<code>alloc</code>都是定义在<code>NSObject</code>里的方法，父对象收到这两个信息并做出正确回应后，新对象才创建完毕</font>。</p>

<pre><code class="language-objc">MyObject * my = [[MyObject alloc] init];
</code></pre>

<p>在<code>OC 2.0</code>里，若创建对象不需要参数，则可以直接使用<code>new</code></p>

<pre><code class="language-objc">MyObject * my = [MyObject new];
</code></pre>

<hr />

<h3 id="方法">方法</h3>

<p>在<code>OC</code>中类可以声明两种类型的方法：实例方法和类方法。实例方法在类的一个具体实例的范围内执行，即要<font color=red>调用实例方法前，需要首先创建类的实例，而类方法不需要创建一个实例</font>。</p>

<p>方法声明包括方法类型标识符，返回值类型，一个或多个方法标识关键字，参数类型和名信息，下图展示 <code>insertObject:atIndex</code>: 实例方法的声明。</p>

<p><img src="http://oqe76o492.bkt.clouddn.com/Snipaste_2018-09-19_17-19-12.png" alt="Snipaste_2018-09-19_17-19-12" /></p>

<p>声明由一个减号<code>-</code>开始，这表明这是一个实例方法。方法实际的名字(<code>insertObject:atIndex:</code>)是所有方法标识关键的级联，包含了冒号。冒号表明了参数的出现。如果方法没有参数，你可以省略第一个(也是唯一的)方法标识关键字后面的冒号。本例中，这个方法有两个参数。</p>

<p>当需要调用一个方法时，即传递消息给对应的对象，这里的消息是指方法标识符以及传递给方法的参数信息。<font color=red>发送给对象的所有消息都会动态分发</font>，这样有利于实现<code>OC</code>的多态行为。<font color=Blue>如果子类定义了和父类具有相同标识符的方法，那么子类首先收到消息，然后选择把收到的消息转发（也可以不转发）给他的父类</font>。</p>

<p>消息被<font color=red>中括号包括</font>。中括号里，接收消息的对象在左边，消息（<font color=red>包括消息需要的任何参数</font>）在右边。例如，给<code>myArray</code>变量传递消息<code>insertObject:atIndex:</code>消息，需要使用如下的语法：</p>

<pre><code class="language-objc">[myArray insertObject:anObj atIndex:0];
</code></pre>

<p>为了避免过多的声明本地变量保存临时结果，<code>OC</code>允许使用嵌套的消息，每个嵌套的消息的返回值可以作为其他消息的参数或者目标。例如，有另外一个对象叫做<code>myAppObject</code>有方法可以访问数组对象，以及插入一个对象到一个数组，就可以将前面的例子写成如下的形式：</p>

<pre><code class="language-objc">[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0];
</code></pre>

<p>消息也可以传递给类本身，当给类发消息的时候，指定的方法必须为类方法。类方法的典型用途是用做创建新的类的实例的工厂方法，或者是访问类相关的共享信息的途径。</p>

<pre><code class="language-objc">NSMutableArray*   myArray = nil; // nil 基本上等同于 NULL

// 创建一个新的数组，并把它赋值给 myArray 变量
myArray = [NSMutableArray arrayWithCapacity:0];
</code></pre>

<p>上面是一个类方法作为一个工厂方法来使用。<code>arrayWithCapacity</code>是<code>NSMutableArray</code>类的类方法，为类的新实例分配内容并初始化，然后返回。</p>

<hr />

<h3 id="属性">属性</h3>

<p>属性使用一个等式来表示：<code>@property = 成员变量 + getter + setter</code>，即一个属性包含了一个成员变量以及该成员变量的<code>getter</code>和<code>setter</code>方法：</p>

<pre><code class="language-objc">@property = 成员变量 + getter + setter
</code></pre>

<p>为什么<code>OC</code>要添加属性，这就要从成员变量说起。成员变量的写法，一般如下：</p>

<pre><code class="language-objc">@interface Person :NSObject
{ 
    int _age;    //定义成员变量，_下划线开始是苹果的编程规范
}
@end 
</code></pre>

<p>成员变量具有如下的特点：</p>

<ul>
<li>只能通过对象来访问</li>
<li>成员变量离不开类，离开了类就不是成员变量</li>
<li>成员变量不能在定义的时候同时进行初始化</li>
<li>成员变量存储在当前对象对应的堆空间中，不会自动释放，只能手动释放</li>
<li>成员变量前加<code>_</code>是苹果的编程规范</li>
</ul>

<p>在<code>OC</code>中<code>.</code>访问符是是为<code>getter</code>和<code>setter</code>服务的，而在<code>OC</code>中成员变量默认是没有<code>getter</code>和<code>setter</code>方法，因此在类外无法直接访问。如果需要访问就要自定义的<code>getter</code>和<code>setter</code>方法，然后通过自定义的<code>getter</code>和<code>setter</code>方法来访问成员变量。</p>

<p>因此，苹果为了大众方便，在<code>iOS 5</code>以后使用了属性<code>@property</code>。定义属性时会自动将<code>getter</code>和<code>setter</code>方法实现了，你无须再手动去实现<code>getter</code>和<code>setter</code>方法。当然了，如果你需要在<code>getter</code>和<code>setter</code>方法中想要做点事情，直接重写就好。</p>

<p>顺带地，<code>@property</code>还<font color=red>会生成一个成员变量，变量名就是<code>_属性名</code></font>。当然这个名字你也可以修改，是在<code>.m</code>文件中的<code>implements中去定义</code>：</p>

<pre><code class="language-objc">@synthesize  name = myName;
</code></pre>

<p><a href="https://www.jianshu.com/p/143125cef4ff">参考文献</a></p>

<p>属性提供了一些关键字用以控制<code>setter</code>和<code>getter</code>的实现细节, 这些关键字我们称为属性的属性(<code>attribute</code>)，总共有三类:</p>

<ul>
<li>读写性<code>readonly,readwrite</code>。其中<code>readonly</code>表示只能读取, 不能写入（系统默认是可读写的）
<br /></li>
</ul>

<pre><code class="language-objc"> @property (readonly)NSString *name; 表示只能读取
 @property (readwrite)NSString *name；表示可以读写
</code></pre>

<ul>
<li>原子性控制<code>atomic，nonatomic</code>。其中<code>atomic</code>表示属性对应的<code>setter</code>和<code>getter</code>方法在多线程访问下绝对安全。而<code>nonatomic</code>表示不做线程安全处理，只是普通的<code>setter</code>和<code>getter</code>方法。使用<code>atomic</code>, 需要<font color=red>不断地对<code>setter</code>和<code>getter</code>加锁解锁以保证线程安全, 会很占用系统资源, 降低系统性能</font>。
<br /></li>
</ul>

<pre><code class="language-objc"> @property(readwrite,nonatomic)NSString *name;表示name 可读写, 无原子性
</code></pre>

<ul>
<li>语义设置<code>assign, retain, copy,strong,weak</code>。这5个属性决定了<code>setter</code>方法中是如何赋值的。

<ul>
<li>其中<code>assign</code>实现<code>setter</code>和<code>getter</code>是直接赋值，计数器不会加一，简单的赋值方法，默认赋值方式，适合基本数据类型。相当于说两个对象指向同个内存区，一个地方的变了，其他的也跟着改变。
<br /></li>
</ul></li>
</ul>

<pre><code class="language-objc">   @property(nonatomic, assign) NSInteger age;
   -(void)setName:(NSInteger )age {
       _age = age;
   }
   -(NSInteger )age {
      return _age;
   }
</code></pre>

<ul>
<li><p><code>strong</code> : 表示强引用关系，即拥有对象的所有权。</p></li>

<li><p><code>weak</code> : 表示弱引用，不拥有对象的所有权，当目标对象被销毁之后，属性值会被自动设为<code>nil</code>;</p></li>

<li><p><code>​copy</code>(拷贝)：把原来的对象拷贝过来，计数器会加一，比如原来对象的地址为<code>0x01</code> ,拷贝过来的对象的地址为<code>0x02</code>。用于希望保持一份传入值的拷贝，而不是值自身的情况，即<font color=red>把原来的对象完整的赋值到另外一地方，重新加载一内存区，一个地方变了不影响另一个地方的对象。</font>是内容拷贝。</p></li>

<li><p><code>​retain</code>(保留)：这种方式传递的是指针，原有的对象和被赋值的对象的地址是一样的。释放旧的对象,将旧对象的值赋予输入对象,再提高输入对象的索引计数为1。是指针拷贝。</p></li>
</ul>

<hr />

<h1 id="设计模式">设计模式</h1>

<p>设计模式的两个目标
- 可复用性：得到较高的生产效率。
- 可扩展性：当用户的需求发生变化时，做很少的变化就能够满足用户的需求。</p>

<h2 id="单例模式">单例模式</h2>

<p>单例设计模式：自始至终一个类只有一个对象实例。<code>Cocoa</code>中主要的单例类有：
- UIApplication
- NSNotificationCenter
- NSUserDefaults
- NSFileManager
- NSBundle</p>

<p><code>OC</code>中单例模式：
<img src="http://oqe76o492.bkt.clouddn.com/2018-10-17-15397585820107.jpg" alt="c600" /></p>

<pre><code class="language-objc">//singleton.h
@interface Singleton:NSObject
+ (Singleton *) sharedManager
@property (nonatomic,strong) NSString * singletonData;
@end

//singleton.m
@implemention Singleton
@synthesize singletonData = _singletonData;
static Singleton * sharedManager = nil
+ (Singleton *) sharedManager{
   static dispatch_once_t once;
   dispatch_once(&amp;once,^{
     sharedManager = [[self alloc] init];
   });
   return sharedManager;
}
</code></pre>

<p>单例设计模式使用场景：
- 在整个过程中只需要一个实例保存状态。
- 无状态对象(只有方法，没有属性）</p>

<p>单例模式时，访问对象时，修改状态的时候要十分小心（它就像一个全局变量）。</p>

<h2 id="uiapplication">UIApplication</h2>

<ul>
<li><code>sharedApplication</code>方法：它是创建和获得<code>UIApplication</code>实例的实例方法。</li>
<li><code>openURL</code>:方法：该方法可以打开一些内置的<code>iOS</code>应用，其中包括打开浏览器、打开<code>Google</code>地图、拨打电话、发送短信和发送<code>Email</code>等。</li>
</ul>

<pre><code class="language-objc">[[UIApplication sharedApplication] openURL: [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
</code></pre>

<hr />

<h2 id="委托模式">委托模式</h2>

<p>委托：<font color=red>某个对象指定另一个对象处理某些特定任务（某些方法的实现）</font>的设计模式。例如当没空的时候委托别人帮忙买火车票，<font color=Blue>乘车人、乘车日期以及出发地和目的地就是协议「规定」</font>（协议通俗的说就是某种规定，如果能执行这种规定就说遵守了某个协议）。</p>

<p><img src="http://oqe76o492.bkt.clouddn.com/2018-10-17-15397621286012.jpg" alt="" /></p>

<p>在上面的类图中带空心三角形的实线表示继承；<font color=red>带空心三角形的虚线表示实现接口</font>；<font color=Blue>带箭头的实线表示单向关联（<code>has</code>）</font>。上面的意思是通用类有一个叫做“委托协议”的成员，它被赋值为（绑定到）为一个委托对象实例，而委托对象实现了委托协议中的相关方法。然后通过这个委托对象实例来做相应的动作（完成委托的事情）。</p>

<ol>
<li><p>委托需要做的工作有：
1.1 定义协议与协议中的方法
1.2 声明委托变量
1.3 设置代理（委托变量绑定到哪个对象实例）
1.4 通过委托变量调用委托方法</p></li>

<li><p>代理需要做的工作有:
2.1 遵循协议（在类的定义时声明遵循相应的协议）
2.2 实现委托方法（实现协议中的方法）</p></li>
</ol>

<h3 id="场景">场景</h3>

<p>场景：<code>Boss</code>准备举行一场<code>party</code>，准备邀请<code>Atany</code>来参加<code>party</code>，但是<code>Boss</code>没空写<code>email</code>给<code>Atany</code>，于是他委托<code>Henry</code>与<code>Mary</code>来做这件事情。</p>

<p>在<code>YGViewController.h</code>（根控制器，程序第一个界面，类似于<code>Boss</code>）中首先定义协议，接着声明委托变量（<code>Boss</code>并没有实现<code>inviteToMyParty</code>这个方法，他没有自己去邀请）：</p>

<pre><code class="language-objc">#import &lt;UIKit/UIKit.h&gt;
@protocol InviteDelegate
-(void)inviteToMyParty:(NSString *)personName;//1.1定义协议与方法
@end

@interface YGViewController : UIViewController
@property (assign,nonatomic) id&lt;InviteDelegate&gt; delegate;//1.2声明委托变量
- (IBAction)ClickByMary:(id)sender;//委托给Mary
- (IBAction)ClickByHenry:(id)sender;//委托给Henry
@end
</code></pre>

<p>然后再设置代理，最后通过委托变量调用委托方法：</p>

<pre><code class="language-objc">- (IBAction)ClickByMary:(id)sender {
    Mary *mary = [[Mary alloc]init];
    self.delegate = mary;//1.3设置代理
    [self.delegate inviteToMyParty:@&quot;atany&quot;];//1.4通过委托变量调用委托方法
}
- (IBAction)ClickByHenry:(id)sender {
    Henry *henry = [[Henry alloc]init];
    self.delegate = henry;//1.3设置代理
    [self.delegate inviteToMyParty:@&quot;atany&quot;];//1.4通过委托变量调用委托方法
}
</code></pre>

<p><code>BOSS</code>可以选择不同的代理（<code>Henry</code>与<code>Mary</code>）来做这件事情（<code>inviteToMyParty</code>），而自己却不用做。以<code>Henry</code>为例，首先遵循协议，然后实现协议中的委托方法：</p>

<pre><code class="language-objc">#import &lt;UIKit/UIKit.h&gt;
#import &quot;YGViewController.h&quot;

@interface Henry : UIViewController &lt;InviteDelegate&gt;//2.1遵循协议
@end

-(void)inviteToMyParty:(NSString *)personName{
    NSString *hello = [NSString stringWithFormat:@&quot;Hello,%@&quot;,personName];
    NSString *str = [NSString stringWithFormat:@&quot;Hey Boy,this is Henry,Come to our party Please!!&quot;];
    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:hello message:str delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil];
    [alert show];
}
</code></pre>

<hr />

<h2 id="观察者设计模式">观察者设计模式</h2>

<p>观察模式的定义</p>

<p>有很多观察者正在观察对象的变化，当对象发生时会通知所有的观察者</p>

<p><code>KVO</code>是观察对象属性的变化
通知机制观察的是对象的变化</p>

<p>NSNotification 可以通过object（NSObject） 和 userInfo（NSDictionary） 来回传数据</p>

<p>投送通知：postNotification</p>

<p>KVO要搞清楚谁是观察者，谁是被观察者</p>

<p>模态视图：关闭不能通过故事板，只能通过代码实现</p>

<h1 id="gcd">GCD</h1>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="https://halohui.github.io/tags/oc" rel="tag" title="OC">#OC#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="https://halohui.github.io/post/home-primer/" rel="next" title="购房准备">
        <i class="fa fa-chevron-left"></i> 购房准备
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="https://halohui.github.io/post/xcode-quick/" rel="prev" title="XCode快捷键">
        XCode快捷键 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     <div class="post-nav">
<div style="border: 1px dashed #e0e0e0; padding: 10px 10px 10px 10px; background-color: #fffeee; background-repeat: no-repeat; background-attachment: scroll; background-position: 1% 50%; -moz-background-size: auto auto; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;">
    <div style="float:left;margin-top:0px;">
    <img src="https://i.loli.net/2018/12/16/5c15cbd7f2b61.jpg" width="128px" height="128px"/>
    <div style="text-align:center;">谢谢支持!</div>
    </div>
    <div>
        <p style="margin-top:10px;">
            标题：OC 入门
        <br />作者：<a target="_blank" href="https://halohui.github.io/">I呆呆</a>
        
        <br />地址：https://halohui.github.io/post/oc-tour/
        <br />声明：自由转载-非商用-保持署名（创作共享3.0许可证）
        </p>
    </div>
</div>
<div class="clear"></div>
</div>
     
     
     




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="https://halohui.github.io/img/mmhui.png"
        alt="I呆呆" />
    <p class="site-author-name" itemprop="name">I呆呆</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="https://halohui.github.io/post/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="https://halohui.github.io/categories/">      
         
        <span class="site-state-item-count">17</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="https://halohui.github.io/tags/">
         
        <span class="site-state-item-count">16</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://coolshell.cn" target="_blank" title="酷 壳">
            <i class="fa fa-fw fa-globe"></i>
            酷 壳
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ideamsg.com" target="_blank" title="灵 感">
            <i class="fa fa-fw fa-globe"></i>
            灵 感
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="http://www.ruanyifeng.com" target="_blank" title="阮一峰">
            <i class="fa fa-fw fa-globe"></i>
            阮一峰
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://github.com/qicosmos/" target="_blank" title="祁 宇">
            <i class="fa fa-fw fa-github"></i>
            祁 宇
        </a>
        </span>
    
</div>

      
      <div class="links-of-blogroll motion-element inline">


</div>
    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
<ul>
<li><a href="#文件扩展名">文件扩展名</a></li>
<li><a href="#语法">语法</a>
<ul>
<li><a href="#调用方法">调用方法</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#类">类</a>
<ul>
<li><a href="#interface">Interface</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#创建对象">创建对象</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#属性">属性</a></li>
</ul></li>
</ul></li>
<li><a href="#设计模式">设计模式</a>
<ul>
<li><a href="#单例模式">单例模式</a></li>
<li><a href="#uiapplication">UIApplication</a></li>
<li><a href="#委托模式">委托模式</a>
<ul>
<li><a href="#场景">场景</a></li>
</ul></li>
<li><a href="#观察者设计模式">观察者设计模式</a></li>
</ul></li>
<li><a href="#gcd">GCD</a></li>
</ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2018 - 2019</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">Keep It Simple</span>
</div>

  

<div class="theme-info">
  
  
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b07433b4ab8d587dae7d34e71973839";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=58416275" charset="UTF-8"></script> 
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="https://halohui.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="https://halohui.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="https://halohui.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="https://halohui.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="https://halohui.github.io/js/utils.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/motion.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/affix.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/post-details.js"></script>
<script type="text/javascript" src="https://halohui.github.io/js/toc.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="https://halohui.github.io/js/search.js"></script>
</body>
</html>
